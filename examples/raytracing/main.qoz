import math "std:cmath"
import "std:strings"
import "std:mem"

Vec3   := alias arr<f64, 3>
Color  := alias Vec3
Stream := alias strings.StringBuilder

Ray       := struct { origin: Vec3, direction: Vec3 }
Sphere    := struct { center: Vec3, radius: f64 }
HitRecord := struct {
    t:          f64,
    p:          Vec3,
    normal:     Vec3,
    front_face: bool
}

Hittable := union {
    Sphere
}

HittableList := struct {
    objects: vec<Hittable>
}


hit_sphere := func(center: Vec3, radius: f64, ray: Ray): f64 {
    oc := center - ray.origin
    a := vec_dot(ray.direction, ray.direction)
    b := -2.0 * vec_dot(ray.direction, oc)
    c := vec_dot(oc, oc) - radius*radius
    disc := b*b - 4.0*a*c

    if disc < 0.0: return -1.0

    return (-b - math.sqrt(disc)) / (2.0*a)
}

vec_dot := func(v1: Vec3, v2: Vec3): f64 {
    mul := v1 * v2
    return mul[0] + mul[1] + mul[2]
}

vec_cross := func(v1: Vec3, v2: Vec3): Vec3 {
    return {
        v1[1] * v2[2] - v1[2] * v2[1],
        v1[2] * v2[0] - v1[0] * v2[2],
        v1[0] * v2[1] - v1[1] * v2[0],
    }
}

vec_length_squared := func(v: Vec3): f64 {
    sqr := v * v
    return sqr[0] + sqr[1] + sqr[2]
}

vec_length := func(v: Vec3): f64 {
    return math.sqrt(vec_length_squared(v))
}

vec_unit_vector := func(v: Vec3): Vec3 {
    return v / vec_length(v)
}

hit_record_set_face_normal := func(rec: HitRecord, ray: Ray, outward_normal: Vec3) {
    rec.front_face = vec_dot(ray.direction, outward_normal) < 0.0
    if rec.front_face {
        rec.normal = outward_normal
    } else {
        rec.normal = -outward_normal
    }
}

ray_at := func(r: Ray, t: f64): Vec3 {
    return r.origin + t * r.direction
}

ray_color := func(r: Ray, objects: *vec<Hittable>): Color {
    t := hit_sphere(Vec3{0.0, 0.0, -1.0}, 0.5, r)
    if t > 0.0 {
        N := vec_unit_vector(ray_at(r, t) - Vec3{0.0, 0.0, -1.0})
        color := Color{ N[0] + 1.0, N[1] + 1.0, N[2] + 1.0 }
        return 0.5 * color
    }

    unit_direction := vec_unit_vector(r.direction)
    a := 0.5 * (unit_direction[1] + 1.0)
    white := Color{1.0, 1.0, 1.0}
    return (1.0 - a) * white + a * Color{0.5, 0.7, 1.0}
}

sphere_hit := func(sphere: Sphere, ray: Ray, tmin: f64, tmax: f64, rec: HitRecord): bool {
    oc := ray.origin - sphere.center
    a := vec_length_squared(ray.direction)
    h := vec_dot(ray.direction, oc)
    c := vec_length_squared(oc) - sphere.radius*sphere.radius

    disc := h*h - a*c
    if disc < 0.0: return false

    // find the nearest root that lies in the acceptable range
    sqrtd := math.sqrt(disc)
    root := (h-sqrtd) / a
    if root <= tmin || tmax <= root {
        root = (h + sqrtd) / a
        if root <= tmin || tmax <= root {
            return false
        }
    }
    rec.t = root
    rec.p = ray_at(ray, rec.t)
    outward_normal := (rec.p - sphere.center) / sphere.radius
    hit_record_set_face_normal(rec, ray, outward_normal)
    return true
}

write_color := func(sb: *Stream, color: Color, alloc: mem.Allocator) {
    cnorm := color * 255.999
    ir := cnorm[0] as i32
    ig := cnorm[1] as i32
    ib := cnorm[2] as i32

    fmt := format("%d %d %d\n", ir, ig, ib, alloc)
    strings.builder_append_string(sb, fmt)
}

main := func() {
    arena := mem.arena_make_growable(4*1024*1024)
    defer mem.arena_free(&arena)
    alloc := mem.arena_allocator(&arena)
    sb := strings.builder_init(alloc)

    aspect_ratio := 16.0 / 9.0
    image_width := 400
    image_height := ((image_width as f64) / aspect_ratio) as i64

    // Camera setup
    focal_length := 1.0
    viewport_height := 2.0
    viewport_width := viewport_height * (image_width as f64) / (image_height as f64)
    camera_center := Vec3{0.0, 0.0, 0.0}

    // Vector across the horizontal and down the vertical viewport edges
    viewport_u := Vec3{viewport_width, 0.0, 0.0}
    viewport_v := Vec3{0.0, -viewport_height, 0.0}

    // Horizontal and vertical delta vectors from pixel to pixel
    pixel_delta_u := viewport_u / image_width
    pixel_delta_v := viewport_v / image_height

    // Location of the upper left pixel
    viewport_upper_left := camera_center - Vec3{0.0, 0.0, focal_length} - viewport_u/2 - viewport_v/2
    pixel00_loc := viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v)

    objects := new(vec<Hittable>, alloc)


    // Render
    dim_line := format("P3\n%d %d\n", image_width, image_height, alloc)
    strings.builder_append_string(&sb, dim_line)
    strings.builder_append_string(&sb, "255\n")
    for j := 0; j < image_height; j += 1 {
        // println("Scanlines remaining:", image_height-j)
        for i := 0; i < image_width; i += 1 {
            pixel_center := pixel00_loc + ((i as f64) * pixel_delta_u) + ((j as f64) * pixel_delta_v)
            ray_direction := pixel_center - camera_center

            ray := Ray{origin: camera_center, direction: ray_direction}
            color := ray_color(ray, objects)
            write_color(&sb, color, alloc)
        }
    }

    result := strings.builder_to_string(&sb, alloc)
    println(result)
}
