import "std:libc"

Arena := struct {
    buffer:   *u8
    offset:   i64
    size:     i64
    next:     *Arena
    growable: bool
}

arena_make := func(size: i64): Arena {
    arena := Arena {
        buffer:   libc.malloc(size) as *u8,
        offset:   0,
        size:     size,
        next:     nil,
        growable: false,
    }
    return arena
}

arena_make_growable := func(initial_size: i64): Arena {
    arena := Arena {
        buffer:   libc.malloc(initial_size) as *u8,
        offset:   0,
        size:     initial_size,
        next:     nil,
        growable: true,
    }
    return arena
}

arena_free := func(arena: *Arena) {
    current := arena
    first_arena := arena
    while current != nil {
        libc.free(current.buffer)
        next := current.next
        // Free arena struct if it was heap-allocated (not the first one)
        if current != first_arena {
            libc.free(current)
        }
        current = next
    }
}

arena_alloc_proc := func(data: *void, size: i64): *void {
    arena := data as *Arena

    // Find the last arena in the chain (where we allocate from)
    current := arena
    while current.next != nil {
        current = current.next
    }

    // Check if allocation fits in current arena
    if current.offset + size > current.size {
        if !current.growable {
            print("Arena out of memory!")
            libc.exit(1)
        }

        // Allocate new arena block: use max(current.size, size) to ensure
        // large allocations get appropriately sized blocks
        // This prevents many small blocks when allocating large objects
        new_block_size := current.size
        if size > new_block_size {
            new_block_size = size
        }
        
        new_buffer := libc.malloc(new_block_size) as *u8
        if new_buffer == nil {
            print("Failed to allocate new arena block!")
            libc.exit(1)
        }

        // Create new arena struct on the stack and link it
        new_arena := Arena {
            buffer:   new_buffer,
            offset:   0,
            size:     new_block_size,
            next:     nil,
            growable: true,
        }

        // Allocate space for the new arena struct in the current arena
        // This allows us to store the new arena struct in the chain
        new_arena_ptr := libc.malloc(48) as *Arena  // sizeof(Arena) = 48 bytes (8+8+8+8+1 with padding)
        if new_arena_ptr == nil {
            libc.free(new_buffer)
            print("Failed to allocate new arena struct!")
            libc.exit(1)
        }

        // Copy arena struct to allocated memory
        new_arena_ptr.buffer = new_buffer
        new_arena_ptr.offset = 0
        new_arena_ptr.size = new_block_size
        new_arena_ptr.next = nil
        new_arena_ptr.growable = true

        // Link new arena to chain
        current.next = new_arena_ptr
        current = new_arena_ptr
    }

    // Allocate from current arena
    ptr := current.buffer + current.offset
    current.offset = current.offset + size

    return ptr as *void
}

// No-op. Arena doesn't support individual frees.
arena_free_proc := func(data: *void, ptr: *void) { }

arena_allocator := func(arena: *Arena): Allocator {
    return Allocator {
        data: arena,
        alloc: arena_alloc_proc,
        free: arena_free_proc
    }
}